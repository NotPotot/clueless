package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
//import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.VoltageSensor;
import com.qualcomm.robotcore.util.ElapsedTime;
//import com.qualcomm.robotcore.hardware.IMU;
//use Navigation and Orientation classes for Field-Centric Driving
import com.qualcomm.robotcore.util.Range;

@TeleOp(name = "Cursor");

public class Cursor extends OpMode {

	private DcMotor fl0;
	private DcMotor fr1;
	private DcMotor bl2;
	private DcMotor br3;
	private DcMotorEx shootmotor;
	private Servo Servo1;

  @Override
  public void init() {
    //everything in here runs once when you press initialize

    telemetry.addData("Status", "Initialized");
    telemetry.update();

    shootmotor = hardwareMap.get(DcMotorEx.class, "shootmotor");
    Servo1 = hardwareMap.get(Servo.class, "Servo1);
    fl0 = hardwareMap.get(DcMotor.class, "fl0");
	fr1 = hardwareMap.get(DcMotor.class, "fr1");
	bl2 = hardwareMap.get(DcMotor.class, "bl2");
	br3 = hardwareMap.get(DcMotor.class, "br3");

    shootmotor.setDirection(DcMotorEx.Direction.FORWARD);
    fl0.setDirection(DcMotor.Direction.REVERSE);
	fr1.setDirection(DcMotor.Direction.FORWARD);
	bl2.setDirection(DcMotor.Direction.REVERSE);
	br3.setDirection(DcMotor.Direction.FORWARD);

    shootmotor.setMode(DcMotorEx.RunMode.RUN_USING_ENCODER);
  }

  public void loop() {

		Movement movement = new Movement();
		Module module = new Module();
		Module.Shooter shooter = module.new Shooter();
		
		movement.drive();
		movement.slide();
		movement.rotation();
		shooter.motor();
		shooter.servo();

  }

  private class Movement {
	public void drive() {
			
			fl0.setPower(gamepad1.right_trigger-gamepad1.left_trigger);
			fr1.setPower(gamepad1.right_trigger-gamepad1.left_trigger);
			bl2.setPower(gamepad1.right_trigger-gamepad1.left_trigger);
			br3.setPower(gamepad1.right_trigger-gamepad1.left_trigger);
			
		}
		
		public void slide() {
			
			fl0.setPower(gamepad1.right_stick_x);
			fr1.setPower(-gamepad1.right_stick_x);
			bl2.setPower(-gamepad1.right_stick_x);
			br3.setPower(gamepad1.right_stick_x);
			
		}
		
		public void rotation() {
			
			fl0.setPower(gamepad1.left_stick_x);
			fr1.setPower(-gamepad1.left_stick_x);
			bl2.setPower(gamepad1.left_stick_x);
			br3.setPower(-gamepad1.left_stick_x);
			
		}

	private class Module {
		public class Shooter {
			public void motor() {
				if (gamepad2.a) {
					shootmotor.setPower(.3);
				} else if (gamepad2.b) {
					shootmotor.setPower(.5);
				} else if (gamepad2.y) {
					shootmotor.setPower(.7);
				} else if (gamepad2.x) {
					shootmotor.setPower(.9);
				} else {
					shootmotor.setPower(0);
				}
			}
			
			public void servo() {
				if (gamepad2.right_bumper) {
					servo0.setPosition(.72);
				}
				if (gamepad2.left_bumper) {
					servo0.setPosition(.4);
				}
			}
			private void velocitycheck(){
				velocity = shootmotor.getVelocity();
				telemetry.addData("Velocity (ticks/sec)", velocity);
		
				// Optional: Also display RPM (RevolutionsPerMinute)
				// Assuming your encoder has 28 ticks per revolution (adjust if different)
				double rpm = (velocity / 28.0) * 60.0;
				telemetry.addData("RPM", rpm);
				
				// Display current power setting
				telemetry.addData("Power", shootmotor.getPower());
			}
		


		}
	}
  }










}
